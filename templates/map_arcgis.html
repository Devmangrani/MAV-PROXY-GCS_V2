<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Road Navigation & Curvature Analysis (OSRM)</title>

  <!-- Load Leaflet -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" crossorigin="anonymous" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js" crossorigin="anonymous"></script>

  <style>
    html, body, #map {
      padding: 0;
      margin: 0;
      height: 100%;
      width: 100%;
    }
    #infoPanel {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      padding: 10px;
      border-radius: 4px;
      width: 300px;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
    }
    #loadingIndicator {
      display: none;
      margin-top: 10px;
      color: #0078A8;
    }
    #routeInfo {
      margin-top: 10px;
      display: none;
    }
    .info-row {
      margin-bottom: 5px;
    }
    button {
      background: #0078A8;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      margin-top: 5px;
    }
    button:hover { background: #005e85; }
    button:disabled { background: #cccccc; cursor: not-allowed; }
    .legend {
      padding: 6px 8px;
      background: white;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      border-radius: 5px;
      line-height: 22px;
      color: #555;
    }
    .legend i {
      width: 18px;
      height: 3px;
      display: inline-block;
      margin-right: 8px;
      vertical-align: middle;
    }
    .waypoint-marker {
      background-color: #FF4500;
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      text-align: center;
      line-height: 20px;
      font-weight: bold;
      border: 2px solid white;
      box-shadow: 0 0 4px rgba(0,0,0,0.4);
    }
    .distance-label {
      background-color: rgba(255, 255, 255, 0.8);
      border: 1px solid #FF4500;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 11px;
      font-weight: bold;
      white-space: nowrap;
      box-shadow: 0 0 3px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="infoPanel">
    <h3>Road Navigation App</h3>
    <p>Click on the map to set start and end points.</p>
    <button id="resetBtn" disabled>Reset Points</button>
    <div id="loadingIndicator">Calculating route...</div>
    <div id="routeInfo">
      <h4>Route Information:</h4>
      <div class="info-row"><strong>Distance:</strong> <span id="distance">-</span></div>
      <div class="info-row"><strong>Optimized Distance:</strong> <span id="optimizedDistance">-</span></div>
      <div class="info-row"><strong>Travel Time:</strong> <span id="time">-</span></div>
      <div class="info-row"><strong>Road Analysis:</strong> <span id="roadType">-</span></div>
      <div class="info-row"><strong>Detected Curves:</strong> <span id="curveCount">-</span></div>
    </div>
  </div>

  <script>
    // Initialize the map at Bhopal, India
    const map = L.map('map').setView([23.193226800701908, 77.36584032380036], 12);

    // Add OpenStreetMap basemap
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // DOM elements
    const resetBtn = document.getElementById("resetBtn");
    const routeInfo = document.getElementById("routeInfo");
    const loadingIndicator = document.getElementById("loadingIndicator");
    const distanceElement = document.getElementById("distance");
    const optimizedDistanceElement = document.getElementById("optimizedDistance");
    const timeElement = document.getElementById("time");
    const roadTypeElement = document.getElementById("roadType");
    const curveCountElement = document.getElementById("curveCount");

    // Variables for the stops
    let markers = [];
    let routePolyline = null;
    let optimizedPolyline = null;
    let curveHighlightPolylines = [];
    let waypointMarkers = []; // Add array to store waypoint markers

    // Add a scale control to the map
    L.control.scale().addTo(map);

    // Add legend to map
    function addLegend() {
      const legend = L.control({position: 'bottomleft'});

      legend.onAdd = function() {
        const div = L.DomUtil.create('div', 'legend');
        div.innerHTML =
          '<h4>Path Legend</h4>' +
          '<i style="background:#0078A8"></i> Road Route<br>' +
          '<i style="background:#FF4500"></i> Drone Flight Path<br>' +
          '<i style="background:#FF0000"></i> Sharp Curve<br>';
        return div;
      };

      legend.addTo(map);
    }

    addLegend();

    // When the map is clicked, add a point
    map.on('click', function(e) {
      if (markers.length >= 2) return;

      const lat = e.latlng.lat;
      const lng = e.latlng.lng;

      // Create a marker for the point
      const markerIcon = L.icon({
        iconUrl: markers.length === 0 ?
          'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png' :
          'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        shadowSize: [41, 41]
      });

      const marker = L.marker([lat, lng], { icon: markerIcon }).addTo(map);
      markers.push(marker);

      // Enable reset button
      resetBtn.disabled = false;

      // If we have two points, calculate the route
      if (markers.length === 2) {
        calculateRoute();
      }
    });

    // Reset function to clear the map
    resetBtn.addEventListener("click", function() {
      // Remove markers
      markers.forEach(marker => map.removeLayer(marker));
      markers = [];

      // Remove route polyline
      if (routePolyline) {
        map.removeLayer(routePolyline);
        routePolyline = null;
      }

      // Remove optimized polyline
      if (optimizedPolyline) {
        map.removeLayer(optimizedPolyline);
        optimizedPolyline = null;
      }

      // Remove curve highlights
      curveHighlightPolylines.forEach(polyline => map.removeLayer(polyline));
      curveHighlightPolylines = [];

      // Remove waypoint markers
      waypointMarkers.forEach(marker => map.removeLayer(marker));
      waypointMarkers = [];

      // Update UI
      resetBtn.disabled = true;
      routeInfo.style.display = "none";
    });

    // Calculate route using OSRM API
    async function calculateRoute() {
      if (markers.length !== 2) return;

      // Show loading
      loadingIndicator.style.display = "block";
      routeInfo.style.display = "none";

      // Get start and end points
      const startPoint = markers[0].getLatLng();
      const endPoint = markers[1].getLatLng();

      // Clear any existing curve highlights
      curveHighlightPolylines.forEach(polyline => map.removeLayer(polyline));
      curveHighlightPolylines = [];

      // Clear any existing waypoint markers
      waypointMarkers.forEach(marker => map.removeLayer(marker));
      waypointMarkers = [];

      try {
        // Build API URL using OSRM public API
        const url = `https://router.project-osrm.org/route/v1/driving/${startPoint.lng},${startPoint.lat};${endPoint.lng},${endPoint.lat}?overview=full&geometries=polyline&steps=true`;

        // Make API request
        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();

        if (data.code !== 'Ok') {
          throw new Error(data.message || 'OSRM API error');
        }

        // Process the route
        const route = data.routes[0];

        // Decode polyline
        const coordinates = decodePolyline(route.geometry);

        // Create polyline for the route
        if (routePolyline) {
          map.removeLayer(routePolyline);
        }

        routePolyline = L.polyline(coordinates, {
          color: '#0078A8',
          weight: 6,
          opacity: 0.7
        }).addTo(map);

        // Analyze road curvature
        const { description, curveSegments } = analyzeRouteCurvature(coordinates);

        // NEW: Calculate drone path
        const dronePathPoints = calculateDronePath(coordinates, 200); // 200 meters visibility

        // Create drone path polyline
        if (optimizedPolyline) {
          map.removeLayer(optimizedPolyline);
        }

        optimizedPolyline = L.polyline(dronePathPoints, {
          color: '#FF4500',
          weight: 4,
          opacity: 0.8
        }).addTo(map);

        // Calculate drone path distance
        let optimizedDistance = 0;
        for (let i = 0; i < dronePathPoints.length - 1; i++) {
          optimizedDistance += calculateHaversineDistance(
            dronePathPoints[i][0], dronePathPoints[i][1],
            dronePathPoints[i+1][0], dronePathPoints[i+1][1]
          );
        }

        // Highlight curve segments on the map
        highlightCurveSegments(curveSegments);

        // Update route info
        const distance = route.distance / 1000; // Convert to km
        const duration = route.duration / 60; // Convert to minutes

        distanceElement.textContent = distance.toFixed(2) + " km";
        optimizedDistanceElement.textContent = optimizedDistance.toFixed(2) + " km";

        // Format duration
        const hours = Math.floor(duration / 60);
        const minutes = Math.round(duration % 60);
        let timeText = "";
        if (hours > 0) {
          timeText += hours + " hr ";
        }
        timeText += minutes + " min";
        timeElement.textContent = timeText;

        roadTypeElement.textContent = description;
        curveCountElement.textContent = dronePathPoints.length + " waypoints";

        // Add numbered markers at each waypoint with distance labels
        dronePathPoints.forEach((point, index) => {
          // Calculate distance from this waypoint to the original route
          const closestPointInfo = findClosestPointOnRoute(point, coordinates);
          const distanceFromRoute = closestPointInfo.distance * 1000; // Convert to meters

          // Create a custom div icon with the waypoint number
          const waypointIcon = L.divIcon({
            className: 'waypoint-marker',
            html: `<div class="waypoint-marker">${index + 1}</div>`,
            iconSize: [24, 24],
            iconAnchor: [12, 12]
          });

          // Add marker with waypoint number
          const marker = L.marker([point[0], point[1]], { icon: waypointIcon }).addTo(map);
          marker.bindPopup(`Waypoint ${index + 1}<br>Distance from route: ${distanceFromRoute.toFixed(1)} m`);
          waypointMarkers.push(marker);

          // Add a label showing the distance from route
          const label = L.marker([point[0], point[1]], {
            icon: L.divIcon({
              className: 'distance-label',
              html: `${distanceFromRoute.toFixed(0)}m`,
              iconSize: [null, null],
              iconAnchor: [15, -15]
            }),
            interactive: false
          }).addTo(map);
          waypointMarkers.push(label);

          // Optional: Draw a line from the waypoint to the closest point on the route
          const routeConnector = L.polyline([
            [point[0], point[1]],
            [closestPointInfo.point[0], closestPointInfo.point[1]]
          ], {
            color: '#FF4500',
            weight: 1.5,
            opacity: 0.6,
            dashArray: '3,5'
          }).addTo(map);
          waypointMarkers.push(routeConnector);
        });

        // Fit map to the route
        map.fitBounds(routePolyline.getBounds(), { padding: [50, 50] });

        // Hide loading, show info
        loadingIndicator.style.display = "none";
        routeInfo.style.display = "block";

      } catch (error) {
        console.error('Error calculating route:', error);

        // Create a straight line between points as fallback
        if (routePolyline) {
          map.removeLayer(routePolyline);
        }
        routePolyline = L.polyline([startPoint, endPoint], {
          color: 'red',
          weight: 4,
          opacity: 0.7,
          dashArray: '5, 10'
        }).addTo(map);

        // Calculate straight-line distance
        const distance = calculateHaversineDistance(
          startPoint.lat, startPoint.lng,
          endPoint.lat, endPoint.lng
        );

        distanceElement.textContent = distance.toFixed(2) + " km (direct)";
        optimizedDistanceElement.textContent = "N/A";
        timeElement.textContent = "N/A";
        roadTypeElement.textContent = "Cannot analyze route: " + error.message;
        curveCountElement.textContent = "0";

        // Hide loading, show info
        loadingIndicator.style.display = "none";
        routeInfo.style.display = "block";
      }
    }

    // Create an optimized path that follows the route but creates shortcuts through curves
    function createOptimizedPath(routeCoordinates, curveSegments) {
      if (curveSegments.length === 0) {
        return routeCoordinates; // No curves to optimize
      }

      const optimizedPath = [];
      let lastIndex = 0;

      // Process each curve segment
      for (let i = 0; i < curveSegments.length; i++) {
        const segment = curveSegments[i];

        // Add all points from last position up to the curve start
        for (let j = lastIndex; j < segment.startIndex; j++) {
          optimizedPath.push(routeCoordinates[j]);
        }

        // Add the start point of the curve
        optimizedPath.push(routeCoordinates[segment.startIndex]);

        // Create a direct path (shortcut) from the start to the end of the curve
        const startPoint = routeCoordinates[segment.startIndex];
        const endPoint = routeCoordinates[segment.endIndex];

        // For very sharp curves, add a few intermediate points for visual clarity
        if (segment.maxChange > 60) {
          const midPoint1 = {
            0: startPoint[0] + (endPoint[0] - startPoint[0]) * 0.33,
            1: startPoint[1] + (endPoint[1] - startPoint[1]) * 0.33
          };

          const midPoint2 = {
            0: startPoint[0] + (endPoint[0] - startPoint[0]) * 0.66,
            1: startPoint[1] + (endPoint[1] - startPoint[1]) * 0.66
          };

          optimizedPath.push([midPoint1[0], midPoint1[1]]);
          optimizedPath.push([midPoint2[0], midPoint2[1]]);
        }

        // Add the end point of the curve
        optimizedPath.push(endPoint);

        // Update the last index for the next segment
        lastIndex = segment.endIndex + 1;
      }

      // Add any remaining points after the last curve
      for (let i = lastIndex; i < routeCoordinates.length; i++) {
        optimizedPath.push(routeCoordinates[i]);
      }

      return optimizedPath;
    }

    // Function to analyze if a route is straight or curved
    function analyzeRouteCurvature(coordinates) {
      if (coordinates.length < 3) {
        return { description: "Too few points to analyze", curveSegments: [] };
      }

      // Calculate total route distance and direct distance
      let totalDistance = 0;
      let directDistance = calculateHaversineDistance(
        coordinates[0][0], coordinates[0][1],
        coordinates[coordinates.length-1][0], coordinates[coordinates.length-1][1]
      );

      // Calculate point-to-point distances
      for (let i = 0; i < coordinates.length - 1; i++) {
        const dist = calculateHaversineDistance(
          coordinates[i][0], coordinates[i][1],
          coordinates[i+1][0], coordinates[i+1][1]
        );
        totalDistance += dist;
      }

      // Calculate bearing changes to detect curves
      let bearingChanges = [];
      for (let i = 0; i < coordinates.length - 2; i++) {
        const bearing1 = calculateBearing(
          coordinates[i][0], coordinates[i][1],
          coordinates[i+1][0], coordinates[i+1][1]
        );
        const bearing2 = calculateBearing(
          coordinates[i+1][0], coordinates[i+1][1],
          coordinates[i+2][0], coordinates[i+2][1]
        );

        // Calculate the absolute bearing change
        let change = Math.abs(bearing2 - bearing1);
        if (change > 180) change = 360 - change;

        bearingChanges.push({
          index: i + 1,
          change: change
        });
      }

      // Identify curves based on bearing changes
      const CURVE_THRESHOLD = 15; // Angle change in degrees to consider a significant curve

      // Find segments with significant curves
      let curveSegments = [];
      let currentSegment = null;

      for (let i = 0; i < bearingChanges.length; i++) {
        const bc = bearingChanges[i];

        if (bc.change > CURVE_THRESHOLD) {
          // Start a new segment if we're not in one
          if (!currentSegment) {
            currentSegment = {
              startIndex: Math.max(0, bc.index - 1),
              endIndex: bc.index + 1,
              maxChange: bc.change
            };
          } else {
            // Extend current segment
            currentSegment.endIndex = bc.index + 1;
            currentSegment.maxChange = Math.max(currentSegment.maxChange, bc.change);
          }
        } else if (currentSegment) {
          // End the current segment
          curveSegments.push(currentSegment);
          currentSegment = null;
        }
      }

      // Add the last segment if there is one
      if (currentSegment) {
        curveSegments.push(currentSegment);
      }

      // Create curve segments with coordinates
      curveSegments = curveSegments.map(segment => {
        return {
          ...segment,
          coordinates: coordinates.slice(segment.startIndex, segment.endIndex + 1)
        };
      });

      // Merge segments that are close to each other
      curveSegments = mergeCloseSegments(curveSegments, 3); // Merge segments within 3 points

      // Calculate metrics
      const directness = directDistance / totalDistance;
      const avgBearingChange = bearingChanges.reduce((a, b) => a + b.change, 0) / bearingChanges.length;
      const sharpTurns = bearingChanges.filter(change => change.change > 45).length;

      // Determine if route is straight or curved
      let routeType = "";

      if (directness > 0.95 && avgBearingChange < 5) {
        routeType = "Very straight road";
      } else if (directness > 0.85 && avgBearingChange < 15) {
        routeType = "Mostly straight with minor curves";
      } else if (directness > 0.7 && avgBearingChange < 25) {
        routeType = "Moderately curved";
      } else {
        routeType = "Winding/curved road";
      }

      // Add additional info about sharp turns
      if (sharpTurns > 0) {
        routeType += ` with ${sharpTurns} sharp turn${sharpTurns > 1 ? 's' : ''}`;
      }

      return { description: routeType, curveSegments: curveSegments };
    }

    // Merge curve segments that are close to each other
    function mergeCloseSegments(segments, maxGap) {
      if (segments.length <= 1) return segments;

      const mergedSegments = [];
      let currentSegment = segments[0];

      for (let i = 1; i < segments.length; i++) {
        const nextSegment = segments[i];

        // Check if segments are close
        if (nextSegment.startIndex - currentSegment.endIndex <= maxGap) {
          // Merge segments
          currentSegment = {
            startIndex: currentSegment.startIndex,
            endIndex: nextSegment.endIndex,
            maxChange: Math.max(currentSegment.maxChange, nextSegment.maxChange),
            coordinates: [...currentSegment.coordinates, ...nextSegment.coordinates.slice(1)]
          };
        } else {
          // Add current segment and start a new one
          mergedSegments.push(currentSegment);
          currentSegment = nextSegment;
        }
      }

      // Add the last segment
      mergedSegments.push(currentSegment);

      return mergedSegments;
    }

    // Add curve highlights to the map
    function highlightCurveSegments(curveSegments) {
      // Remove existing curve highlights
      curveHighlightPolylines.forEach(polyline => map.removeLayer(polyline));
      curveHighlightPolylines = [];

      // Add new curve highlights
      curveSegments.forEach(segment => {
        const polyline = L.polyline(segment.coordinates, {
          color: '#FF0000',
          weight: 8,
          opacity: 0.8
        }).addTo(map);

        // Add a popup with curve information
        polyline.bindPopup(`Curve with ${segment.maxChange.toFixed(1)}° angle change`);

        curveHighlightPolylines.push(polyline);
      });
    }

    // Decode Google polyline format
    function decodePolyline(encodedPolyline) {
      const points = [];
      let index = 0, lat = 0, lng = 0;

      while (index < encodedPolyline.length) {
        let b, shift = 0, result = 0;

        do {
          b = encodedPolyline.charCodeAt(index++) - 63;
          result |= (b & 0x1f) << shift;
          shift += 5;
        } while (b >= 0x20);

        const dlat = ((result & 1) ? ~(result >> 1) : (result >> 1));
        lat += dlat;

        shift = 0;
        result = 0;

        do {
          b = encodedPolyline.charCodeAt(index++) - 63;
          result |= (b & 0x1f) << shift;
          shift += 5;
        } while (b >= 0x20);

        const dlng = ((result & 1) ? ~(result >> 1) : (result >> 1));
        lng += dlng;

        points.push([lat / 1e5, lng / 1e5]);
      }

      return points;
    }

    // Function to calculate distance between two points (Haversine formula)
    function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371; // Radius of the earth in km
      const dLat = deg2rad(lat2 - lat1);
      const dLon = deg2rad(lon2 - lon1);
      const a =
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      const distance = R * c; // Distance in km
      return distance;
    }

    // Full calculateDronePath function
    function calculateDronePath(routeCoordinates, minWaypointDistance = 200) {
      // Step 1: Apply Douglas-Peucker algorithm for initial simplification
      const epsilon = 0.1; // Simplification threshold in meters (lower = more waypoints)
      let simplifiedPoints = douglasPeuckerSimplify(routeCoordinates, epsilon);

      // Step 2: Ensure waypoints are at least minWaypointDistance apart
      // and handle visibility constraints
      let finalPoints = [simplifiedPoints[0]]; // Start with the first point

      // Process each point after the first one
      for (let i = 1; i < simplifiedPoints.length; i++) {
        const lastAddedPoint = finalPoints[finalPoints.length - 1];
        const currentPoint = simplifiedPoints[i];

        // Calculate distance between the last added point and current point
        const distance = calculateHaversineDistance(
          lastAddedPoint[0], lastAddedPoint[1],
          currentPoint[0], currentPoint[1]
        ) * 1000; // Convert km to meters

        // If the distance is at least the minimum required, add the point
        if (distance >= minWaypointDistance) {
          finalPoints.push(currentPoint);
        } else if (i === simplifiedPoints.length - 1) {
          // Always include the last point regardless of distance
          finalPoints.push(currentPoint);
        }
        // Skip points that are too close
      }

      // Step 3: Add intermediate points for segments that are too far apart
      let distanceAdjustedPoints = [];
      for (let i = 0; i < finalPoints.length - 1; i++) {
        const startPoint = finalPoints[i];
        const endPoint = finalPoints[i + 1];
        distanceAdjustedPoints.push(startPoint);

        // Calculate distance between consecutive points
        const distance = calculateHaversineDistance(
          startPoint[0], startPoint[1],
          endPoint[0], endPoint[1]
        ) * 1000; // Convert km to meters

        // If the distance is too large, add intermediate points
        const maxDistance = minWaypointDistance * 0.2; // Allow up to 1.5x the minimum distance
        if (distance > maxDistance) {
          // Calculate how many intermediate points to add
          const numIntermediatePoints = Math.floor(distance / minWaypointDistance) - 1;

          for (let j = 1; j <= numIntermediatePoints; j++) {
            const fraction = j / (numIntermediatePoints + 1);
            const intermediatePoint = [
              startPoint[0] + fraction * (endPoint[0] - startPoint[0]),
              startPoint[1] + fraction * (endPoint[1] - startPoint[1])
            ];
            distanceAdjustedPoints.push(intermediatePoint);
          }
        }
      }

      // Add the final point
      distanceAdjustedPoints.push(finalPoints[finalPoints.length - 1]);

      // Step 4: Check for sharp curves and add waypoints if necessary
      const sharpCurveThreshold = 5; // Angle in degrees (lower = more waypoints at curves)
      let curveAdjustedPoints = [];

      for (let i = 0; i < distanceAdjustedPoints.length - 2; i++) {
        curveAdjustedPoints.push(distanceAdjustedPoints[i]);

        const bearing1 = calculateBearing(
          distanceAdjustedPoints[i][0], distanceAdjustedPoints[i][1],
          distanceAdjustedPoints[i+1][0], distanceAdjustedPoints[i+1][1]
        );

        const bearing2 = calculateBearing(
          distanceAdjustedPoints[i+1][0], distanceAdjustedPoints[i+1][1],
          distanceAdjustedPoints[i+2][0], distanceAdjustedPoints[i+2][1]
        );

        // Calculate the absolute bearing change
        let change = Math.abs(bearing2 - bearing1);
        if (change > 180) change = 360 - change;

        // Add waypoint at significant bearing changes
        if (change > sharpCurveThreshold) {
          const curvePoint = distanceAdjustedPoints[i+1];

          // Check if this curve point is too close to the previous point
          const prevPoint = curveAdjustedPoints[curveAdjustedPoints.length - 1];
          const distToPrev = calculateHaversineDistance(
            prevPoint[0], prevPoint[1],
            curvePoint[0], curvePoint[1]
          ) * 1000; // Convert km to meters

          // Only add the curve point if it's far enough from the previous point
          if (distToPrev >= minWaypointDistance * 0.09) { // Allow 30% of the minimum distance for curve points
            curveAdjustedPoints.push(curvePoint);
          }
        }
      }

      // Add the last two points
      if (distanceAdjustedPoints.length >= 2) {
        const lastPoint = distanceAdjustedPoints[distanceAdjustedPoints.length - 1];
        const secondLastPoint = distanceAdjustedPoints[distanceAdjustedPoints.length - 2];

        // Check if the second last point is already included
        const lastIncludedPoint = curveAdjustedPoints[curveAdjustedPoints.length - 1];
        if (!arePointsEqual(lastIncludedPoint, secondLastPoint)) {
          curveAdjustedPoints.push(secondLastPoint);
        }

        // Check if the last point is already included
        if (!arePointsEqual(curveAdjustedPoints[curveAdjustedPoints.length - 1], lastPoint)) {
          curveAdjustedPoints.push(lastPoint);
        }
      }

      // Step 5: Final distance check to ensure minimum distance between all points
      let finalAdjustedPoints = [curveAdjustedPoints[0]]; // Start with first point

      for (let i = 1; i < curveAdjustedPoints.length; i++) {
        const lastPoint = finalAdjustedPoints[finalAdjustedPoints.length - 1];
        const currentPoint = curveAdjustedPoints[i];

        const distance = calculateHaversineDistance(
          lastPoint[0], lastPoint[1],
          currentPoint[0], currentPoint[1]
        ) * 1000; // Convert km to meters

        // Include point if it's far enough away or it's the last point
        if (distance >= minWaypointDistance * 0.1 || i === curveAdjustedPoints.length - 1) {
          finalAdjustedPoints.push(currentPoint);
        }
      }

      // Add waypoint numbering for UI display
      finalAdjustedPoints.forEach((point, index) => {
        point.waypointNumber = index + 1;
      });

      console.log(`Generated ${finalAdjustedPoints.length} waypoints for drone path`);

      return finalAdjustedPoints;
    }

    function updateRouteInfo(routeDistance, dronePathPoints, duration, roadDescription) {
      distanceElement.textContent = routeDistance.toFixed(2) + " km";

      // Calculate drone path distance
      let optimizedDistance = 0;
      for (let i = 0; i < dronePathPoints.length - 1; i++) {
        optimizedDistance += calculateHaversineDistance(
          dronePathPoints[i][0], dronePathPoints[i][1],
          dronePathPoints[i+1][0], dronePathPoints[i+1][1]
        );
      }
      optimizedDistanceElement.textContent = optimizedDistance.toFixed(2) + " km";

      // Format duration
      const hours = Math.floor(duration / 60);
      const minutes = Math.round(duration % 60);
      let timeText = "";
      if (hours > 0) {
        timeText += hours + " hr ";
      }
      timeText += minutes + " min";
      timeElement.textContent = timeText;

      roadTypeElement.textContent = roadDescription;

      // Show waypoint count with detailed information
      curveCountElement.textContent = `${dronePathPoints.length} waypoints`;

      // Create waypoint markers with numbers
      dronePathPoints.forEach((point, index) => {
        // Create a custom icon with the waypoint number
        const waypointIcon = L.divIcon({
          className: 'waypoint-icon',
          html: `<div style="background-color:#FF4500; color:white; border-radius:50%; width:20px; height:20px;
                  text-align:center; line-height:20px; font-weight:bold;">${index + 1}</div>`,
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        });

        // Add marker with waypoint number
        const marker = L.marker([point[0], point[1]], { icon: waypointIcon }).addTo(map);
        marker.bindPopup(`Waypoint ${index + 1}`);
      });
    }

    // Douglas-Peucker algorithm for path simplification
    function douglasPeuckerSimplify(points, epsilon) {
      if (points.length <= 2) {
        return points;
      }

      // Find the point with the maximum distance
      let maxDistance = 0;
      let maxDistanceIndex = 0;

      for (let i = 1; i < points.length - 1; i++) {
        const distance = perpendicularDistance(
          points[i],
          points[0],
          points[points.length - 1]
        );

        if (distance > maxDistance) {
          maxDistance = distance;
          maxDistanceIndex = i;
        }
      }

      // If max distance is greater than epsilon, recursively simplify
      if (maxDistance > epsilon) {
        // Recursive call
        const firstLine = douglasPeuckerSimplify(
          points.slice(0, maxDistanceIndex + 1),
          epsilon
        );
        const secondLine = douglasPeuckerSimplify(
          points.slice(maxDistanceIndex),
          epsilon
        );

        // Concat the two simplified segments
        return firstLine.slice(0, -1).concat(secondLine);
      } else {
        // Return the end points of the line
        return [points[0], points[points.length - 1]];
      }
    }

    // Calculate perpendicular distance from point to line
    function perpendicularDistance(point, lineStart, lineEnd) {
      // Convert lat/lng to meters to get proper distance
      const x0 = point[1];      // longitude
      const y0 = point[0];      // latitude
      const x1 = lineStart[1];  // longitude
      const y1 = lineStart[0];  // latitude
      const x2 = lineEnd[1];    // longitude
      const y2 = lineEnd[0];    // latitude

      // Calculate the denominator of the formula
      const denominator = Math.sqrt(
        Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2)
      );

      // Avoid division by zero
      if (denominator === 0) {
        return 0;
      }

      // Calculate perpendicular distance
      const numerator = Math.abs(
        (y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1
      );

      // Convert to kilometers
      const distanceInDegrees = numerator / denominator;
      return distanceInDegrees * 111.32; // Rough conversion to km at equator
    }

    // Get all points on the original path between two simplified points
    function getAllPointsBetween(allPoints, start, end) {
      let startIndex = -1;
      let endIndex = -1;

      // Find indices of start and end points
      for (let i = 0; i < allPoints.length; i++) {
        if (arePointsEqual(allPoints[i], start)) {
          startIndex = i;
        }
        if (arePointsEqual(allPoints[i], end)) {
          endIndex = i;
          break;
        }
      }

      // Handle cases where points aren't found
      if (startIndex === -1 || endIndex === -1) {
        // Find the closest points if exact matches aren't found
        if (startIndex === -1) {
          startIndex = findClosestPointIndex(allPoints, start);
        }
        if (endIndex === -1) {
          endIndex = findClosestPointIndex(allPoints, end);
        }
      }

      // Ensure startIndex is less than endIndex
      if (startIndex > endIndex) {
        [startIndex, endIndex] = [endIndex, startIndex];
      }

      // Return the points between (inclusive)
      return allPoints.slice(startIndex, endIndex + 1);
    }

    // Check if two points are equal
    function arePointsEqual(point1, point2) {
      return point1[0] === point2[0] && point1[1] === point2[1];
    }

    // Find index of closest point in a list to a target point
    function findClosestPointIndex(points, targetPoint) {
      let minDistance = Infinity;
      let closestIndex = 0;

      for (let i = 0; i < points.length; i++) {
        const distance = calculateHaversineDistance(
          points[i][0], points[i][1],
          targetPoint[0], targetPoint[1]
        );

        if (distance < minDistance) {
          minDistance = distance;
          closestIndex = i;
        }
      }

      return closestIndex;
    }

    // Find the closest point on the route to a given point
    function findClosestPointOnRoute(point, routeCoordinates) {
      let minDistance = Infinity;
      let closestPoint = null;
      let closestSegmentIndex = -1;

      // Check each segment of the route
      for (let i = 0; i < routeCoordinates.length - 1; i++) {
        const segmentStart = routeCoordinates[i];
        const segmentEnd = routeCoordinates[i + 1];

        // Calculate the closest point on this segment to our target point
        const closestPointOnSegment = findClosestPointOnSegment(
          point, segmentStart, segmentEnd
        );

        // Calculate distance to this point
        const distance = calculateHaversineDistance(
          point[0], point[1],
          closestPointOnSegment[0], closestPointOnSegment[1]
        );

        // If this is the closest so far, update our result
        if (distance < minDistance) {
          minDistance = distance;
          closestPoint = closestPointOnSegment;
          closestSegmentIndex = i;
        }
      }

      return {
        point: closestPoint,
        distance: minDistance,
        segmentIndex: closestSegmentIndex
      };
    }

    // Find the closest point on a line segment to a given point
    function findClosestPointOnSegment(point, segmentStart, segmentEnd) {
      // Convert to Cartesian coords for vector math (rough approximation)
      const p = [point[1], point[0]]; // [lon, lat]
      const v = [segmentStart[1], segmentStart[0]];
      const w = [segmentEnd[1], segmentEnd[0]];

      // Calculate vectors
      const vw = [w[0] - v[0], w[1] - v[1]];
      const vp = [p[0] - v[0], p[1] - v[1]];

      // Calculate dot products
      const vwDotVw = vw[0] * vw[0] + vw[1] * vw[1];
      const vwDotVp = vw[0] * vp[0] + vw[1] * vp[1];

      // Calculate projection ratio
      let t = vwDotVp / vwDotVw;

      // Constrain to segment
      t = Math.max(0, Math.min(1, t));

      // Calculate closest point
      const closestPoint = [
        v[1] + t * (w[1] - v[1]), // lat
        v[0] + t * (w[0] - v[0])  // lon
      ];

      return closestPoint;
    }

    // Function to calculate bearing between two points
    function calculateBearing(lat1, lon1, lat2, lon2) {
      lat1 = deg2rad(lat1);
      lon1 = deg2rad(lon1);
      lat2 = deg2rad(lat2);
      lon2 = deg2rad(lon2);
      
      const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) -
                Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
      let bearing = Math.atan2(y, x);
      
      bearing = rad2deg(bearing);
      bearing = (bearing + 360) % 360; // Normalize to 0-360
      
      return bearing;
    }
    
    function deg2rad(deg) {
      return deg * (Math.PI/180);
    }
    
    function rad2deg(rad) {
      return rad * (180/Math.PI);
    }
  </script>
</body>
</html>